<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alfie's Dream</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            touch-action: manipulation; /* Prevent zoom on mobile */
        }

        .game-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            margin: 0 0 20px 0;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 1.2em;
            font-weight: bold;
        }

        #gameCanvas {
            border: 3px solid #fff;
            border-radius: 10px;
            background: #2c3e50;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            touch-action: none; /* Prevent default touch behaviors */
            cursor: grab;
        }

        #gameCanvas:active {
            cursor: grabbing;
        }

        .controls {
            margin-top: 15px;
            text-align: center;
            font-size: 1.1em;
        }

        .controls p {
            margin: 5px 0;
        }

        .restart-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 1.1em;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            transition: background 0.3s;
        }

        .restart-btn:hover {
            background: #c0392b;
        }

        /* Mobile-specific styles */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .game-info {
                font-size: 1em;
            }
            
            #gameCanvas {
                max-width: 100vw;
                max-height: 60vh;
            }
            
            .restart-btn {
                padding: 12px 20px;
                font-size: 1em;
                margin: 3px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>ðŸŽ® Alfie's Dream</h1>
        
        <div class="game-info">
            <div>Score: <span id="score">0</span></div>
            <div>Items Collected: <span id="itemCount">0</span></div>
            <div>Level: <span id="currentLevel">1</span> - <span id="levelName">Easy</span></div>
        </div>
        
        <canvas id="gameCanvas" width="600" height="400"></canvas>
        
        <div class="controls">
            <p>ðŸŽ¯ <span class="desktop-controls">Use ARROW KEYS or WASD to move</span><span class="mobile-controls" style="display:none;">Drag Alfie to move around!</span></p>
            <p>ðŸ¥• Collect the carrots to increase your score!</p>
            <div style="margin: 10px 0;">
                <button class="restart-btn" onclick="startMusic()" style="background: #27ae60;">ðŸŽµ Play Music</button>
                <button class="restart-btn" onclick="stopMusic()" style="background: #e67e22;">ðŸ”‡ Stop Music</button>
            </div>
            <button class="restart-btn" onclick="restartGame()">Restart Game</button>
        </div>
    </div>

    <script>
        // Game variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const itemCountElement = document.getElementById('itemCount');
        const currentLevelElement = document.getElementById('currentLevel');
        const levelNameElement = document.getElementById('levelName');

        // Touch/mouse input variables
        let isMouseDown = false;
        let isDragging = false;
        let touchStartX = 0;
        let touchStartY = 0;
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // Update controls text for mobile
        if (isMobile) {
            document.querySelector('.desktop-controls').style.display = 'none';
            document.querySelector('.mobile-controls').style.display = 'inline';
        }

        // Audio context for background music
        let audioContext;
        let musicGain;
        let isPlaying = false;

        // Initialize audio context and create calming background music
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                musicGain = audioContext.createGain();
                musicGain.connect(audioContext.destination);
                musicGain.gain.value = 0.1; // Low volume for background music
            } catch (e) {
                console.log('Web Audio API not supported:', e);
                audioContext = null;
            }
        }

        // Create a gentle tone
        function createTone(frequency, duration, startTime, fadeIn = 0.1, fadeOut = 0.1) {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(musicGain);
            
            // Use a soft sine wave
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(frequency, startTime);
            
            // Gentle volume envelope
            gainNode.gain.setValueAtTime(0, startTime);
            gainNode.gain.linearRampToValueAtTime(0.3, startTime + fadeIn);
            gainNode.gain.linearRampToValueAtTime(0.3, startTime + duration - fadeOut);
            gainNode.gain.linearRampToValueAtTime(0, startTime + duration);
            
            oscillator.start(startTime);
            oscillator.stop(startTime + duration);
        }

        // Create tinkling sound effect for collecting carrots
        function playTinkleSound() {
            try {
                if (!audioContext || audioContext.state !== 'running') return;
                
                const now = audioContext.currentTime;
                
                // Create a magical tinkling sound with multiple frequencies
                const frequencies = [523.25, 659.25, 783.99, 1046.5]; // C5, E5, G5, C6
                
                frequencies.forEach((freq, index) => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination); // Direct to output for sound effects
                    
                    // Use sine wave for pure tone
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(freq, now + index * 0.05);
                    
                    // Quick, bright envelope for tinkling effect
                    gainNode.gain.setValueAtTime(0, now + index * 0.05);
                    gainNode.gain.setValueAtTime(0.15, now + index * 0.05 + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + index * 0.05 + 0.3);
                    
                    oscillator.start(now + index * 0.05);
                    oscillator.stop(now + index * 0.05 + 0.3);
                });
            } catch (error) {
                console.log('Audio error:', error);
                // Continue game even if audio fails
            }
        }

        // Play calming background music loop
        function playBackgroundMusic() {
            if (!audioContext || isPlaying) return;
            
            isPlaying = true;
            const now = audioContext.currentTime;
            
            // Gentle chord progression in C major pentatonic (calming scale)
            const notes = [
                { freq: 261.63, time: 0 },    // C4
                { freq: 329.63, time: 2 },    // E4
                { freq: 392.00, time: 4 },    // G4
                { freq: 523.25, time: 6 },    // C5
                { freq: 392.00, time: 8 },    // G4
                { freq: 329.63, time: 10 },   // E4
                { freq: 293.66, time: 12 },   // D4
                { freq: 261.63, time: 14 }    // C4
            ];
            
            // Play the melody
            notes.forEach(note => {
                createTone(note.freq, 2.5, now + note.time, 0.2, 0.3);
                // Add a soft harmony (fifth above)
                createTone(note.freq * 1.5, 2.5, now + note.time, 0.2, 0.3);
            });
            
            // Schedule next loop
            setTimeout(() => {
                isPlaying = false;
                if (audioContext && audioContext.state === 'running') {
                    playBackgroundMusic();
                }
            }, 16000); // 16 seconds loop
        }

        // Start music (must be triggered by user interaction)
        function startMusic() {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
            playBackgroundMusic();
        }

        // Stop music
        function stopMusic() {
            if (audioContext) {
                audioContext.suspend();
                isPlaying = false;
            }
        }

        let gameState = {
            player: {
                x: canvas.width / 2,
                y: canvas.height / 2,
                size: 15,
                speed: 3,
                color: '#3498db'
            },
            items: [],
            score: 0,
            itemsCollected: 0,
            keys: {},
            lastFireworkMilestone: 0,
            fireworks: [],
            currentLevel: 1,
            levelName: "Easy"
        };

        // Get mouse/touch position relative to canvas
        function getEventPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            let clientX, clientY;
            
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        // Check if point is inside player
        function isPointInPlayer(x, y) {
            const dx = x - gameState.player.x;
            const dy = y - gameState.player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance <= gameState.player.size * 1.5; // Slightly larger hit area for easier touch
        }

        // Mouse/Touch event handlers
        function handleStart(e) {
            e.preventDefault();
            const pos = getEventPos(e);
            
            if (isPointInPlayer(pos.x, pos.y)) {
                isMouseDown = true;
                touchStartX = pos.x;
                touchStartY = pos.y;
                canvas.style.cursor = 'grabbing';
            }
        }

        function handleMove(e) {
            e.preventDefault();
            if (!isMouseDown) return;
            
            const pos = getEventPos(e);
            const deltaX = pos.x - touchStartX;
            const deltaY = pos.y - touchStartY;
            
            // Only start dragging if moved more than a small threshold
            if (!isDragging && (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5)) {
                isDragging = true;
            }
            
            if (isDragging) {
                // Move player to touch/mouse position
                gameState.player.x = pos.x;
                gameState.player.y = pos.y;
                
                // Keep player within canvas bounds
                gameState.player.x = Math.max(gameState.player.size, Math.min(canvas.width - gameState.player.size, gameState.player.x));
                gameState.player.y = Math.max(gameState.player.size, Math.min(canvas.height - gameState.player.size, gameState.player.y));
            }
        }

        function handleEnd(e) {
            e.preventDefault();
            isMouseDown = false;
            isDragging = false;
            canvas.style.cursor = 'grab';
        }

        // Add event listeners for both mouse and touch
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', handleEnd);

        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd, { passive: false });
        canvas.addEventListener('touchcancel', handleEnd, { passive: false });

        // Item class
        class CollectibleItem {
            constructor() {
                this.x = Math.random() * (canvas.width - 20) + 10;
                this.y = Math.random() * (canvas.height - 20) + 10;
                this.size = 8;
                this.color = '#ff6b35';
                this.pulse = 0;
                this.moveSpeed = 0;
                this.moveAngle = Math.random() * Math.PI * 2;
                this.originalX = this.x;
                this.originalY = this.y;
                
                // Set movement based on current level
                if (gameState.currentLevel >= 2) {
                    this.moveSpeed = gameState.currentLevel >= 4 ? 1.5 : 0.8; // Extreme level moves faster
                }
            }

            update() {
                this.pulse += 0.1;
                
                // Move carrot in higher levels
                if (this.moveSpeed > 0) {
                    this.moveAngle += 0.02;
                    this.x = this.originalX + Math.sin(this.moveAngle) * 30;
                    this.y = this.originalY + Math.cos(this.moveAngle * 0.7) * 20;
                    
                    // Keep within bounds
                    this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x));
                    this.y = Math.max(this.size, Math.min(canvas.height - this.size, this.y));
                }
            }

            draw() {
                ctx.save();
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10 + Math.sin(this.pulse) * 3;
                
                // Draw carrot shape
                this.drawCarrot(this.x, this.y, this.size + Math.sin(this.pulse) * 1);
                ctx.restore();
            }

            drawCarrot(x, y, size) {
                // Draw carrot body (orange triangle)
                ctx.fillStyle = '#ff6b35';
                ctx.beginPath();
                ctx.moveTo(x, y + size);
                ctx.lineTo(x - size * 0.6, y - size * 0.3);
                ctx.lineTo(x + size * 0.6, y - size * 0.3);
                ctx.closePath();
                ctx.fill();
                
                // Draw carrot lines
                ctx.strokeStyle = '#e55039';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x - size * 0.3, y);
                ctx.lineTo(x + size * 0.3, y);
                ctx.moveTo(x - size * 0.2, y - size * 0.2);
                ctx.lineTo(x + size * 0.2, y - size * 0.2);
                ctx.stroke();
                
                // Draw carrot top (green leaves)
                ctx.fillStyle = '#27ae60';
                ctx.beginPath();
                ctx.moveTo(x - size * 0.4, y - size * 0.3);
                ctx.lineTo(x - size * 0.2, y - size * 0.8);
                ctx.lineTo(x, y - size * 0.3);
                ctx.lineTo(x + size * 0.2, y - size * 0.8);
                ctx.lineTo(x + size * 0.4, y - size * 0.3);
                ctx.fill();
            }
        }

        // Firework particle class
        class FireworkParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.life = 1.0;
                this.decay = Math.random() * 0.02 + 0.01;
                this.size = Math.random() * 3 + 1;
                this.color = `hsl(${Math.random() * 360}, 100%, 70%)`;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.1; // gravity
                this.life -= this.decay;
                this.vx *= 0.98; // air resistance
                this.vy *= 0.98;
            }

            draw() {
                if (this.life <= 0) return;
                
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            isDead() {
                return this.life <= 0;
            }
        }

        // Create fireworks explosion
        function createFireworks() {
            for (let i = 0; i < 5; i++) { // 5 fireworks
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height * 0.5 + canvas.height * 0.1;
                
                // Create particles for each firework
                for (let j = 0; j < 15; j++) {
                    gameState.fireworks.push(new FireworkParticle(x, y));
                }
            }
        }

        // Update and draw fireworks
        function updateFireworks() {
            for (let i = gameState.fireworks.length - 1; i >= 0; i--) {
                const particle = gameState.fireworks[i];
                particle.update();
                particle.draw();
                
                if (particle.isDead()) {
                    gameState.fireworks.splice(i, 1);
                }
            }
        }

        // Play fireworks sound effect
        function playFireworksSound() {
            try {
                if (!audioContext || audioContext.state !== 'running') return;
                
                const now = audioContext.currentTime;
                
                // Create explosion sound with multiple frequencies
                for (let i = 0; i < 5; i++) {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    // Random low frequency for explosion effect
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(Math.random() * 200 + 100, now + i * 0.1);
                    
                    // Quick burst envelope
                    gainNode.gain.setValueAtTime(0, now + i * 0.1);
                    gainNode.gain.setValueAtTime(0.3, now + i * 0.1 + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + i * 0.1 + 0.5);
                    
                    oscillator.start(now + i * 0.1);
                    oscillator.stop(now + i * 0.1 + 0.5);
                }
                
                // Add high-pitched celebratory notes
                const celebrationNotes = [523.25, 659.25, 783.99, 1046.5, 1318.5]; // C5 to E6
                celebrationNotes.forEach((freq, index) => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(freq, now + 0.5 + index * 0.1);
                    
                    gainNode.gain.setValueAtTime(0, now + 0.5 + index * 0.1);
                    gainNode.gain.setValueAtTime(0.2, now + 0.5 + index * 0.1 + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.5 + index * 0.1 + 0.4);
                    
                    oscillator.start(now + 0.5 + index * 0.1);
                    oscillator.stop(now + 0.5 + index * 0.1 + 0.4);
                });
                
            } catch (error) {
                console.log('Fireworks sound error:', error);
            }
        }

        // Initialize game
        function initGame() {
            gameState.player.x = canvas.width / 2;
            gameState.player.y = canvas.height / 2;
            gameState.items = [];
            gameState.score = 0;
            gameState.itemsCollected = 0;
            gameState.lastFireworkMilestone = 0;
            gameState.fireworks = [];
            gameState.currentLevel = 1;
            gameState.levelName = "Easy";
            gameState.player.speed = 3;
            
            // Spawn initial items for Easy level
            for (let i = 0; i < 8; i++) {
                spawnItem();
            }
            
            updateUI();
        }

        // Spawn new collectible item
        function spawnItem() {
            let newItem;
            let attempts = 0;
            
            do {
                newItem = new CollectibleItem();
                attempts++;
            } while (getDistance(newItem, gameState.player) < 50 && attempts < 10);
            
            gameState.items.push(newItem);
        }

        // Calculate distance between two objects
        function getDistance(obj1, obj2) {
            const dx = obj1.x - obj2.x;
            const dy = obj1.y - obj2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Handle player movement (keyboard only - touch is handled by event listeners)
        function updatePlayer() {
            // Only process keyboard input if not dragging
            if (!isDragging) {
                const player = gameState.player;
                
                if (gameState.keys['ArrowLeft'] || gameState.keys['a'] || gameState.keys['A']) {
                    player.x -= player.speed;
                }
                if (gameState.keys['ArrowRight'] || gameState.keys['d'] || gameState.keys['D']) {
                    player.x += player.speed;
                }
                if (gameState.keys['ArrowUp'] || gameState.keys['w'] || gameState.keys['W']) {
                    player.y -= player.speed;
                }
                if (gameState.keys['ArrowDown'] || gameState.keys['s'] || gameState.keys['S']) {
                    player.y += player.speed;
                }

                // Keep player within canvas bounds
                player.x = Math.max(player.size, Math.min(canvas.width - player.size, player.x));
                player.y = Math.max(player.size, Math.min(canvas.height - player.size, player.y));
            }
        }

        // Check for collisions
        function checkCollisions() {
            for (let i = gameState.items.length - 1; i >= 0; i--) {
                const item = gameState.items[i];
                const distance = getDistance(gameState.player, item);
                
                if (distance < gameState.player.size + item.size) {
                    // Collision detected
                    gameState.items.splice(i, 1);
                    gameState.score += 10;
                    gameState.itemsCollected++;
                    
                    // Try to play tinkling sound effect (but don't break game if it fails)
                    try {
                        playTinkleSound();
                    } catch (error) {
                        console.log('Sound effect error:', error);
                    }
                    
                    // Check for fireworks trigger every 500 points
                    const currentMilestone = Math.floor(gameState.score / 500);
                    if (currentMilestone > gameState.lastFireworkMilestone && gameState.score >= 500) {
                        gameState.lastFireworkMilestone = currentMilestone;
                        createFireworks();
                        try {
                            playFireworksSound();
                        } catch (error) {
                            console.log('Fireworks sound error:', error);
                        }
                    }
                    
                    // Spawn new item
                    spawnItem();
                    
                    // Update level based on new score
                    updateLevel();
                    
                    updateUI();
                }
            }
        }

        // Update UI elements
        function updateUI() {
            scoreElement.textContent = gameState.score;
            itemCountElement.textContent = gameState.itemsCollected;
            currentLevelElement.textContent = gameState.currentLevel;
            levelNameElement.textContent = gameState.levelName;
        }

        // Level management functions
        function getLevelInfo(score) {
            if (score < 500) {
                return { level: 1, name: "Easy", speed: 3, itemCount: 8, spawnRate: 1 };
            } else if (score < 1000) {
                return { level: 2, name: "Medium", speed: 4, itemCount: 6, spawnRate: 0.8 };
            } else if (score < 1500) {
                return { level: 3, name: "Hard", speed: 5, itemCount: 5, spawnRate: 0.6 };
            } else {
                return { level: 4, name: "Extreme", speed: 6, itemCount: 4, spawnRate: 0.4 };
            }
        }

        function updateLevel() {
            const levelInfo = getLevelInfo(gameState.score);
            const oldLevel = gameState.currentLevel;
            
            gameState.currentLevel = levelInfo.level;
            gameState.levelName = levelInfo.name;
            gameState.player.speed = levelInfo.speed;
            
            // If level changed, show level up notification
            if (oldLevel !== levelInfo.level) {
                showLevelUpNotification(levelInfo.name);
                
                // Adjust item count for new level
                while (gameState.items.length > levelInfo.itemCount) {
                    gameState.items.pop();
                }
                while (gameState.items.length < levelInfo.itemCount) {
                    spawnItem();
                }
            }
        }

        function showLevelUpNotification(levelName) {
            // Create a temporary notification overlay
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 20px 40px;
                border-radius: 10px;
                font-size: 24px;
                font-weight: bold;
                z-index: 1000;
                text-align: center;
                border: 3px solid gold;
            `;
            notification.innerHTML = `ðŸŽ‰ LEVEL UP! ðŸŽ‰<br>Welcome to ${levelName} Level!`;
            document.body.appendChild(notification);
            
            // Remove notification after 3 seconds
            setTimeout(() => {
                document.body.removeChild(notification);
            }, 3000);
        }

        // Draw player
        function drawPlayer() {
            const player = gameState.player;
            ctx.save();
            
            // Add a slight glow effect when being dragged
            if (isDragging) {
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 20;
            }
            
            // Draw guinea pig body
            ctx.fillStyle = '#8b4513';
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 2;
            if (!isDragging) {
                ctx.shadowColor = player.color;
                ctx.shadowBlur = 10;
            }
            
            // Main body (oval shape)
            ctx.beginPath();
            ctx.ellipse(player.x, player.y, player.size, player.size * 0.8, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Draw guinea pig ears
            ctx.fillStyle = '#d2691e';
            ctx.beginPath();
            // Left ear
            ctx.ellipse(player.x - player.size * 0.6, player.y - player.size * 0.7, player.size * 0.3, player.size * 0.5, -0.3, 0, Math.PI * 2);
            // Right ear
            ctx.ellipse(player.x + player.size * 0.6, player.y - player.size * 0.7, player.size * 0.3, player.size * 0.5, 0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner ears
            ctx.fillStyle = '#ff69b4';
            ctx.beginPath();
            ctx.ellipse(player.x - player.size * 0.6, player.y - player.size * 0.7, player.size * 0.15, player.size * 0.25, -0.3, 0, Math.PI * 2);
            ctx.ellipse(player.x + player.size * 0.6, player.y - player.size * 0.7, player.size * 0.15, player.size * 0.25, 0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw guinea pig face
            // Eyes
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(player.x - 4, player.y - 3, 2, 0, Math.PI * 2);
            ctx.arc(player.x + 4, player.y - 3, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Eye shine
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(player.x - 3, player.y - 4, 1, 0, Math.PI * 2);
            ctx.arc(player.x + 5, player.y - 4, 1, 0, Math.PI * 2);
            ctx.fill();
            
            // Snout
            ctx.fillStyle = '#ff69b4';
            ctx.beginPath();
            ctx.ellipse(player.x, player.y + 2, 3, 2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Nose
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(player.x, player.y + 1, 1, 0, Math.PI * 2);
            ctx.fill();
            
            // Mouth
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(player.x, player.y + 3, 2, 0, Math.PI);
            ctx.stroke();
            
            // Whiskers
            ctx.beginPath();
            ctx.moveTo(player.x - 8, player.y);
            ctx.lineTo(player.x - 12, player.y - 1);
            ctx.moveTo(player.x - 8, player.y + 2);
            ctx.lineTo(player.x - 12, player.y + 2);
            ctx.moveTo(player.x + 8, player.y);
            ctx.lineTo(player.x + 12, player.y - 1);
            ctx.moveTo(player.x + 8, player.y + 2);
            ctx.lineTo(player.x + 12, player.y + 2);
            ctx.stroke();
            
            ctx.restore();
        }

        // Draw dreamy background
        function drawDreamyBackground() {
            // Create gradient background that changes with level
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            
            if (gameState.currentLevel === 1) {
                // Easy - Soft pink gradient
                gradient.addColorStop(0, '#ff9a9e');
                gradient.addColorStop(0.3, '#fecfef');
                gradient.addColorStop(0.6, '#fecfef');
                gradient.addColorStop(1, '#ffd1ff');
            } else if (gameState.currentLevel === 2) {
                // Medium - Blue gradient
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(0.3, '#764ba2');
                gradient.addColorStop(0.6, '#667eea');
                gradient.addColorStop(1, '#764ba2');
            } else if (gameState.currentLevel === 3) {
                // Hard - Purple gradient
                gradient.addColorStop(0, '#8360c3');
                gradient.addColorStop(0.3, '#2ebf91');
                gradient.addColorStop(0.6, '#8360c3');
                gradient.addColorStop(1, '#2ebf91');
            } else {
                // Extreme - Dark red gradient
                gradient.addColorStop(0, '#ff416c');
                gradient.addColorStop(0.3, '#ff4b2b');
                gradient.addColorStop(0.6, '#ff416c');
                gradient.addColorStop(1, '#ff4b2b');
            }
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add floating dreamy clouds
            const time = Date.now() * 0.001;
            ctx.save();
            
            // Cloud 1
            drawCloud(100 + Math.sin(time * 0.5) * 20, 50 + Math.cos(time * 0.3) * 10, 40, 'rgba(255, 255, 255, 0.3)');
            // Cloud 2
            drawCloud(300 + Math.sin(time * 0.7) * 30, 80 + Math.cos(time * 0.4) * 15, 35, 'rgba(255, 255, 255, 0.25)');
            // Cloud 3
            drawCloud(500 + Math.sin(time * 0.4) * 25, 120 + Math.cos(time * 0.6) * 12, 45, 'rgba(255, 255, 255, 0.2)');
            
            // Add floating sparkles
            for (let i = 0; i < 8; i++) {
                const sparkleX = (canvas.width / 8) * i + Math.sin(time + i) * 30;
                const sparkleY = 200 + Math.sin(time * 0.8 + i * 0.5) * 50;
                drawSparkle(sparkleX, sparkleY, 2 + Math.sin(time * 2 + i) * 1);
            }
            
            ctx.restore();
        }
        
        // Draw a fluffy cloud
        function drawCloud(x, y, size, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            // Main cloud body
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.arc(x + size * 0.5, y, size * 0.8, 0, Math.PI * 2);
            ctx.arc(x - size * 0.5, y, size * 0.8, 0, Math.PI * 2);
            ctx.arc(x + size * 0.25, y - size * 0.5, size * 0.6, 0, Math.PI * 2);
            ctx.arc(x - size * 0.25, y - size * 0.5, size * 0.6, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Draw a twinkling sparkle
        function drawSparkle(x, y, size) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Date.now() * 0.005);
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
            ctx.shadowBlur = 5;
            
            // Draw cross shape sparkle
            ctx.fillRect(-size, -size/4, size*2, size/2);
            ctx.fillRect(-size/4, -size, size/2, size*2);
            
            ctx.restore();
        }

        // Main game loop
        function gameLoop() {
            // Clear canvas and draw dreamy background
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawDreamyBackground();
            
            // Update game objects
            updatePlayer();
            checkCollisions();
            
            // Update and draw items
            gameState.items.forEach(item => {
                item.update();
                item.draw();
            });
            
            // Update and draw fireworks
            updateFireworks();
            
            // Draw player
            drawPlayer();
            
            // Continue game loop
            requestAnimationFrame(gameLoop);
        }

        // Event listeners for keyboard (still works for desktop)
        window.addEventListener('keydown', (e) => {
            gameState.keys[e.key] = true;
            e.preventDefault();
        });

        window.addEventListener('keyup', (e) => {
            gameState.keys[e.key] = false;
        });

        // Restart game function
        function restartGame() {
            initGame();
        }

        // Start the game
        initAudio();
        initGame();
        gameLoop();
    </script>
</body>
</html>
